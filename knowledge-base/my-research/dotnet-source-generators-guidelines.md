# .NET / C# Source Generators Specification

## Overview

This specification provides comprehensive guidance on using .NET Source Generators, with a focus on generating domain models from input files (JSON, YAML, etc.). Source generators are a powerful compile-time metaprogramming feature that enables code generation based on project content.

## Core Concepts

### What Are Source Generators?

Source generators are components that run during compilation to:
- Inspect your code and project files
- Generate additional C# source files
- Add generated code to the compilation
- Enable compile-time metaprogramming without runtime reflection

### Key Characteristics

- **Compile-time execution**: Run during build, not at runtime
- **Additive only**: Cannot modify existing code, only add new code
- **IDE integration**: Run during design-time for IntelliSense support
- **Performance critical**: Must be efficient to avoid impacting IDE experience

## Architecture

### IIncrementalGenerator (Required)

> **Important**: `ISourceGenerator` is deprecated as of .NET 9. Always use `IIncrementalGenerator`.

```csharp
[Generator]
public class DomainModelGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Pipeline-based generation logic
    }
}
```

### Pipeline Architecture

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    // 1. Define data sources
    var jsonFiles = context.AdditionalTextsProvider
        .Where(file => file.Path.EndsWith(".json"));
    
    // 2. Transform data
    var models = jsonFiles
        .Select((file, ct) => ParseJsonToModel(file, ct))
        .Where(model => model != null);
    
    // 3. Generate output
    context.RegisterSourceOutput(models, GenerateCode);
}
```

## Working with Input Files

### Configuring Additional Files

In the consuming project's `.csproj`:

```xml
<ItemGroup>
  <!-- Single file -->
  <AdditionalFiles Include="Models\domain.json" />
  
  <!-- Pattern matching -->
  <AdditionalFiles Include="**\*.schema.json" />
  <AdditionalFiles Include="Config\*.yaml" />
  
  <!-- With metadata -->
  <AdditionalFiles Include="api-spec.yaml">
    <GeneratorMetadata>Type=OpenApi;Version=3.0</GeneratorMetadata>
  </AdditionalFiles>
</ItemGroup>
```

### Reading Additional Files

```csharp
var additionalFiles = context.AdditionalTextsProvider
    .Select((text, cancellationToken) =>
    {
        var content = text.GetText(cancellationToken)?.ToString();
        var path = text.Path;
        
        // Extract metadata if needed
        context.AnalyzerConfigOptionsProvider
            .GetOptions(text)
            .TryGetValue("build_metadata.AdditionalFiles.GeneratorMetadata", out var metadata);
        
        return new FileData(path, content, metadata);
    });
```

## Domain Model Generation Examples

### Example 1: JSON Schema to C# Models

**Input: `person.schema.json`**
```json
{
  "type": "object",
  "properties": {
    "id": { "type": "integer" },
    "name": { "type": "string" },
    "email": { "type": "string", "format": "email" },
    "age": { "type": "integer", "minimum": 0 },
    "tags": { "type": "array", "items": { "type": "string" } }
  },
  "required": ["id", "name"]
}
```

**Generator Implementation:**
```csharp
[Generator]
public class JsonSchemaModelGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var jsonSchemas = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".schema.json"))
            .Select((file, ct) => 
            {
                var json = file.GetText(ct)?.ToString();
                if (string.IsNullOrEmpty(json)) return null;
                
                var schema = JsonDocument.Parse(json);
                var fileName = Path.GetFileNameWithoutExtension(file.Path);
                var className = ToPascalCase(fileName);
                
                return new SchemaInfo
                {
                    ClassName = className,
                    Properties = ExtractProperties(schema.RootElement),
                    Namespace = "GeneratedModels"
                };
            })
            .Where(info => info != null);
        
        context.RegisterSourceOutput(jsonSchemas, GenerateModel);
    }
    
    private void GenerateModel(SourceProductionContext context, SchemaInfo schema)
    {
        var source = GenerateClassSource(schema);
        context.AddSource($"{schema.ClassName}.g.cs", source);
    }
    
    private string GenerateClassSource(SchemaInfo schema)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"namespace {schema.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {schema.ClassName}");
        sb.AppendLine("    {");
        
        foreach (var prop in schema.Properties)
        {
            var type = GetCSharpType(prop);
            var nullable = prop.IsRequired ? "" : "?";
            
            sb.AppendLine($"        public {type}{nullable} {prop.Name} {{ get; set; }}");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
}

record SchemaInfo
{
    public string ClassName { get; init; }
    public string Namespace { get; init; }
    public ImmutableArray<PropertyInfo> Properties { get; init; }
}

record PropertyInfo(string Name, string Type, bool IsRequired);
```

**Generated Output:**
```csharp
// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;

namespace GeneratedModels
{
    public partial class Person
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string? Email { get; set; }
        public int? Age { get; set; }
        public List<string>? Tags { get; set; }
    }
}
```

### Example 2: YAML Configuration to Strongly-Typed Settings

**Input: `appsettings.yaml`**
```yaml
database:
  connectionString: "Server=localhost;Database=MyApp"
  maxConnections: 100
  timeout: 30

features:
  enableCache: true
  cacheSize: 1000
  features:
    - "feature1"
    - "feature2"

logging:
  level: "Information"
  targets:
    - type: "Console"
      format: "json"
    - type: "File"
      path: "logs/app.log"
```

**Generator Implementation:**
```csharp
[Generator]
public class YamlSettingsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var yamlFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".yaml") || file.Path.EndsWith(".yml"))
            .Where(file => Path.GetFileName(file.Path).StartsWith("appsettings"))
            .Select((file, ct) => ParseYamlSettings(file, ct));
        
        context.RegisterSourceOutput(yamlFiles, GenerateSettingsClass);
    }
    
    private SettingsModel ParseYamlSettings(AdditionalText file, CancellationToken ct)
    {
        var yaml = file.GetText(ct)?.ToString();
        if (string.IsNullOrEmpty(yaml)) return null;
        
        var deserializer = new DeserializerBuilder().Build();
        var yamlObject = deserializer.Deserialize<Dictionary<object, object>>(yaml);
        
        return new SettingsModel
        {
            FileName = Path.GetFileNameWithoutExtension(file.Path),
            Sections = ExtractSections(yamlObject)
        };
    }
    
    private void GenerateSettingsClass(SourceProductionContext context, SettingsModel model)
    {
        var className = $"{ToPascalCase(model.FileName)}Configuration";
        var source = new StringBuilder();
        
        source.AppendLine("// <auto-generated/>");
        source.AppendLine("using System;");
        source.AppendLine("using System.Collections.Generic;");
        source.AppendLine();
        source.AppendLine("namespace AppSettings");
        source.AppendLine("{");
        
        // Generate main configuration class
        source.AppendLine($"    public class {className}");
        source.AppendLine("    {");
        
        foreach (var section in model.Sections)
        {
            var typeName = $"{section.Name}Settings";
            source.AppendLine($"        public {typeName} {section.Name} {{ get; set; }} = new();");
        }
        
        source.AppendLine("    }");
        source.AppendLine();
        
        // Generate nested classes for each section
        foreach (var section in model.Sections)
        {
            GenerateSettingsSection(source, section);
        }
        
        source.AppendLine("}");
        
        context.AddSource($"{className}.g.cs", source.ToString());
    }
    
    private void GenerateSettingsSection(StringBuilder source, SectionModel section)
    {
        source.AppendLine($"    public class {section.Name}Settings");
        source.AppendLine("    {");
        
        foreach (var property in section.Properties)
        {
            var type = InferType(property.Value);
            source.AppendLine($"        public {type} {property.Key} {{ get; set; }}");
        }
        
        source.AppendLine("    }");
        source.AppendLine();
    }
}
```

### Example 3: CSV to Entity Models

**Input: `products.csv`**
```csv
Id,Name,Price,Category,InStock
1,Laptop,999.99,Electronics,true
2,Mouse,29.99,Electronics,true
3,Notebook,4.99,Stationery,false
```

**Generator Implementation:**
```csharp
[Generator]
public class CsvModelGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var csvFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".csv"))
            .Select((file, ct) =>
            {
                var content = file.GetText(ct)?.ToString();
                if (string.IsNullOrEmpty(content)) return null;
                
                var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
                if (lines.Length < 2) return null;
                
                var headers = lines[0].Split(',');
                var sampleRow = lines[1].Split(',');
                
                return new CsvModel
                {
                    ClassName = ToPascalCase(Path.GetFileNameWithoutExtension(file.Path)),
                    Columns = headers.Zip(sampleRow, (header, sample) => 
                        new ColumnInfo(header.Trim(), InferTypeFromSample(sample.Trim())))
                        .ToImmutableArray()
                };
            })
            .Where(model => model != null);
        
        context.RegisterSourceOutput(csvFiles, (context, model) =>
        {
            var source = GenerateCsvEntity(model);
            context.AddSource($"{model.ClassName}.g.cs", source);
        });
    }
    
    private string GenerateCsvEntity(CsvModel model)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using CsvHelper.Configuration.Attributes;");
        sb.AppendLine();
        sb.AppendLine("namespace DataModels");
        sb.AppendLine("{");
        sb.AppendLine($"    public class {model.ClassName}");
        sb.AppendLine("    {");
        
        for (int i = 0; i < model.Columns.Length; i++)
        {
            var column = model.Columns[i];
            sb.AppendLine($"        [Index({i})]");
            sb.AppendLine($"        [Name(\"{column.Name}\")]");
            sb.AppendLine($"        public {column.Type} {column.Name} {{ get; set; }}");
            sb.AppendLine();
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    private string InferTypeFromSample(string sample)
    {
        if (bool.TryParse(sample, out _)) return "bool";
        if (int.TryParse(sample, out _)) return "int";
        if (decimal.TryParse(sample, out _)) return "decimal";
        if (DateTime.TryParse(sample, out _)) return "DateTime";
        return "string";
    }
}
```

## Advanced Patterns

### 1. Attribute-Driven Generation

```csharp
// Usage in user code
[GenerateFromJson("Models/product.json")]
public partial class Product { }

// Generator implementation
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    var classesWithAttribute = context.SyntaxProvider
        .ForAttributeWithMetadataName(
            "GenerateFromJsonAttribute",
            predicate: (node, _) => node is ClassDeclarationSyntax,
            transform: (ctx, _) =>
            {
                var classSymbol = ctx.TargetSymbol as INamedTypeSymbol;
                var attribute = ctx.Attributes.First();
                var jsonPath = attribute.ConstructorArguments[0].Value?.ToString();
                
                return new GenerationRequest
                {
                    ClassName = classSymbol.Name,
                    Namespace = classSymbol.ContainingNamespace.ToDisplayString(),
                    JsonPath = jsonPath
                };
            });
    
    var combined = classesWithAttribute
        .Combine(context.AdditionalTextsProvider.Collect())
        .Select((pair, ct) =>
        {
            var (request, files) = pair;
            var file = files.FirstOrDefault(f => f.Path.EndsWith(request.JsonPath));
            if (file == null) return null;
            
            var json = file.GetText(ct)?.ToString();
            return new { Request = request, Json = json };
        })
        .Where(x => x != null);
    
    context.RegisterSourceOutput(combined, GeneratePartialClass);
}
```

### 2. Multi-File Generation

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    var apiSpec = context.AdditionalTextsProvider
        .Where(f => f.Path.EndsWith("api-spec.yaml"))
        .Select((file, ct) => ParseOpenApiSpec(file, ct));
    
    // Generate multiple files from single input
    context.RegisterSourceOutput(apiSpec, (ctx, spec) =>
    {
        // Generate models
        foreach (var model in spec.Models)
        {
            var modelSource = GenerateModel(model);
            ctx.AddSource($"{model.Name}.g.cs", modelSource);
        }
        
        // Generate API client
        var clientSource = GenerateApiClient(spec);
        ctx.AddSource("ApiClient.g.cs", clientSource);
        
        // Generate interfaces
        var interfaceSource = GenerateInterfaces(spec);
        ctx.AddSource("IApiClient.g.cs", interfaceSource);
    });
}
```

### 3. Incremental Updates

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    // Cache parsed schemas to avoid reparsing unchanged files
    var schemas = context.AdditionalTextsProvider
        .Where(f => f.Path.EndsWith(".schema.json"))
        .Select((file, ct) =>
        {
            var content = file.GetText(ct)?.ToString();
            var hash = GetStableHash(content);
            
            return new CacheEntry
            {
                Path = file.Path,
                Hash = hash,
                Schema = ParseSchema(content)
            };
        })
        .WithComparer(CacheEntryComparer.Instance);
    
    // Only regenerate when schema actually changes
    context.RegisterSourceOutput(schemas, GenerateFromSchema);
}

// Custom comparer for incremental caching
class CacheEntryComparer : IEqualityComparer<CacheEntry>
{
    public bool Equals(CacheEntry x, CacheEntry y) 
        => x.Path == y.Path && x.Hash == y.Hash;
    
    public int GetHashCode(CacheEntry obj) 
        => HashCode.Combine(obj.Path, obj.Hash);
}
```

## Debugging Source Generators

### Method 1: Roslyn Component Debugging

1. Install "NET Compiler Platform SDK" in Visual Studio
2. Create launch profile in generator project:

```json
{
  "profiles": {
    "Debug Generator": {
      "commandName": "DebugRoslynComponent",
      "targetProject": "../MyApp/MyApp.csproj"
    }
  }
}
```

3. Set breakpoints and press F5

### Method 2: Debugger.Launch()

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
#if DEBUG
    if (!Debugger.IsAttached)
    {
        Debugger.Launch();
    }
#endif
    // Generator logic
}
```

### Method 3: Logging

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    // Log to file during generation
    var logFile = Path.Combine(Path.GetTempPath(), "generator.log");
    
    context.RegisterPostInitializationOutput(ctx =>
    {
        File.AppendAllText(logFile, $"[{DateTime.Now}] Generator initialized\n");
    });
    
    var files = context.AdditionalTextsProvider
        .Select((file, ct) =>
        {
            File.AppendAllText(logFile, $"[{DateTime.Now}] Processing: {file.Path}\n");
            return ProcessFile(file, ct);
        });
}
```

## Testing Source Generators

### Unit Testing

```csharp
[TestClass]
public class GeneratorTests
{
    [TestMethod]
    public async Task GeneratesModelFromJson()
    {
        var source = @"
[GenerateFromJson(""person.json"")]
public partial class Person { }
";

        var json = @"{
  ""properties"": {
    ""name"": { ""type"": ""string"" },
    ""age"": { ""type"": ""integer"" }
  }
}";

        var compilation = CreateCompilation(source);
        
        var generator = new JsonModelGenerator();
        var driver = CSharpGeneratorDriver.Create(generator)
            .AddAdditionalTexts(ImmutableArray.Create<AdditionalText>(
                new InMemoryAdditionalText("person.json", json)));
        
        driver = driver.RunGeneratorsAndUpdateCompilation(
            compilation, 
            out var outputCompilation, 
            out var diagnostics);
        
        // Verify no errors
        Assert.IsFalse(diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error));
        
        // Verify generated code
        var generatedFiles = driver.GetRunResult().GeneratedTrees;
        Assert.AreEqual(1, generatedFiles.Length);
        
        var generatedSource = generatedFiles[0].ToString();
        Assert.IsTrue(generatedSource.Contains("public string Name { get; set; }"));
        Assert.IsTrue(generatedSource.Contains("public int Age { get; set; }"));
    }
}

// Helper for in-memory additional files
class InMemoryAdditionalText : AdditionalText
{
    private readonly string _path;
    private readonly string _content;
    
    public InMemoryAdditionalText(string path, string content)
    {
        _path = path;
        _content = content;
    }
    
    public override string Path => _path;
    
    public override SourceText GetText(CancellationToken cancellationToken = default)
        => SourceText.From(_content);
}
```

### Snapshot Testing

```csharp
[TestMethod]
public async Task GeneratorSnapshot()
{
    var result = await GenerateCode("input.json");
    
    // Use Verify or similar snapshot testing library
    await Verify(result);
}
```

## Performance Best Practices

### 1. Use ForAttributeWithMetadataName

```csharp
// ❌ Bad: Examines every syntax node
context.SyntaxProvider
    .CreateSyntaxProvider(
        predicate: (node, _) => node is ClassDeclarationSyntax cds &&
            cds.AttributeLists.Any(/* complex check */),
        transform: /* ... */);

// ✅ Good: Efficient attribute lookup
context.SyntaxProvider
    .ForAttributeWithMetadataName(
        "MyNamespace.GenerateAttribute",
        predicate: (node, _) => node is ClassDeclarationSyntax,
        transform: /* ... */);
```

### 2. Extract Data Early

```csharp
// ❌ Bad: Passing symbols through pipeline
var classes = context.SyntaxProvider
    .ForAttributeWithMetadataName(/* ... */)
    .Select((ctx, _) => ctx.TargetSymbol); // ISymbol in pipeline

// ✅ Good: Extract needed data immediately
var models = context.SyntaxProvider
    .ForAttributeWithMetadataName(/* ... */)
    .Select((ctx, _) => new ModelInfo
    {
        Name = ctx.TargetSymbol.Name,
        Namespace = ctx.TargetSymbol.ContainingNamespace.ToDisplayString(),
        Properties = ExtractProperties(ctx.TargetSymbol)
    });
```

### 3. Implement Proper Equality

```csharp
// Use records for automatic equality
record ModelInfo(string Name, string Namespace, ImmutableArray<PropertyInfo> Properties);

// Or implement IEquatable<T>
struct ModelInfo : IEquatable<ModelInfo>
{
    public bool Equals(ModelInfo other) 
        => Name == other.Name && 
           Namespace == other.Namespace &&
           Properties.SequenceEqual(other.Properties);
}
```

## Packaging and Distribution

### NuGet Package Structure

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <IsPackable>true</IsPackable>
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <DevelopmentDependency>true</DevelopmentDependency>
  </PropertyGroup>

  <ItemGroup>
    <!-- Generator dependencies -->
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" PrivateAssets="all" />
    <PackageReference Include="System.Text.Json" Version="8.0.0" GeneratePathProperty="true" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <!-- Package the generator dll in the analyzer directory -->
    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="analyzers/dotnet/cs" />
    
    <!-- Include dependencies -->
    <None Include="$(PKGSystem_Text_Json)\lib\netstandard2.0\*.dll" Pack="true" PackagePath="analyzers/dotnet/cs" />
  </ItemGroup>
</Project>
```

### Multi-Targeting

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netstandard2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.0.0" 
                      Condition="'$(TargetFramework)' == 'netstandard2.0'" />
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" 
                      Condition="'$(TargetFramework)' != 'netstandard2.0'" />
  </ItemGroup>
</Project>
```

## Common Pitfalls and Solutions

### 1. Generator Not Running

**Problem**: Generator doesn't execute
**Solution**: Ensure proper project references

```xml
<ItemGroup>
  <ProjectReference Include="..\MyGenerator\MyGenerator.csproj" 
                    OutputItemType="Analyzer" 
                    ReferenceOutputAssembly="false" />
</ItemGroup>
```

### 2. Additional Files Not Found

**Problem**: Generator can't find additional files
**Solution**: Files must be in consuming project

```xml
<!-- In the project using the generator, not the generator project -->
<ItemGroup>
  <AdditionalFiles Include="schema.json" />
</ItemGroup>
```

### 3. Poor IDE Performance

**Problem**: Typing lag in Visual Studio
**Solution**: Optimize incrementality

```csharp
// Use specific file filters
var relevantFiles = context.AdditionalTextsProvider
    .Where(f => f.Path.EndsWith(".model.json")); // Don't process all files

// Cache expensive operations
var parsed = relevantFiles
    .Select((f, ct) => (Path: f.Path, Hash: GetHash(f), Data: Parse(f)))
    .WithComparer(HashComparer.Instance); // Only reparse on changes
```

## Conclusion

Source generators provide a powerful way to eliminate boilerplate code and improve performance by moving code generation to compile-time. When working with input files like JSON or YAML, they enable type-safe, AOT-friendly code generation that would otherwise require runtime reflection. Following the patterns and best practices in this specification will help you build efficient, maintainable source generators.